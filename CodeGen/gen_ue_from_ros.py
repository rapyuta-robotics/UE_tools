# Copyright 2021-2022 Rapyuta Robotics Co., Ltd.
'''
Gen UE wrapper of ros cpp generated by `colcon build` from [.action, .msg, .src]
'''
import struct
from jinja2 import Environment, FileSystemLoader
import sys
import os
import glob
import re
import argparse
from pathlib import Path

import logging
logging.basicConfig(
    level=logging.INFO,
    handlers=[
        logging.FileHandler("codegen_debug.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# default dependency pkgs. Commonly used pkgs
# https://github.com/ros2/common_interfaces +  alpha
# BASE_ROS_INSTALL_PATH = '/opt/ros/foxy/share'
DEFAULT_DEPENDENCY_PKGS = {
    # 'action_msgs': '',
    'actionlib_msgs': '',
    'builtin_interfaces': '',
    # 'unique_identifier_msgs': '',
    # 'diagnostic_msgs': '',
    # 'rosgraph_msgs': '',
    # 'geometry_msgs': '',
    # 'nav_msgs': '',
    # 'sensor_msgs': '',
    # 'shape_msgs': '',
    'std_msgs': '',
    # 'std_srvs': 'StdSrv',
    # 'stereo_msgs': '',
    # 'trajectory_msgs': '',
    # 'visualization_msgs': '',
    # 'tf2_msgs': '',
    # 'pcl_msgs': '',
    #'ackermann_msgs': '',
    # 'example_interfaces': '',
    # 'ue_msgs': ''
}
# DEFAULT_DEPENDENCY_PKGS = {os.path.join(BASE_ROS_INSTALL_PATH, k):v for (k, v) in DEFAULT_DEPENDENCY_PKGS.items()}

# for shorten the class name to meet the UE limitation, maximum 32 charcters for class name
DEFAULT_NAME_MAPPING = {
    'Covariance': 'Cov',
    'Accel': 'Acc',
    'Vector': 'Vec',
    'Quaternion': 'Quat',
    'Trajectory': 'Traj',
    'Transform': 'TF',
    'Compressed': 'Comp',
    'Error': 'Err',
    'Diagnostics': 'Diag',
    'MultiArray': 'MA',
    'Dimension': 'Dim',
    'With': '',
    'Destination': 'Dest',
    'Reservation': 'Reserv',
    'Exception': 'Except',
    'Config': 'Conf',
    'InteractiveMarker': 'IM',
    'Control': 'Ctrl',
    'Request': 'Req',
    'Response': 'Res',
    'Message': 'Msg',
    'String': 'Str',
    'Image': 'Img',
    'Odometry': 'Odom'
}

# constants
UE_SPECIFIC_TYPES = [
    'geometry_msgs/Vector3', 
    'geometry_msgs/Point', 
    # 'geometry_msgs/Point32', 
    'geometry_msgs/Quaternion',
    'geometry_msgs/Transform'
]

# ros build in types
# https://docs.ros.org/en/foxy/Concepts/About-ROS-Interfaces.html
ROS_BUILDIN_TYPES = [
    'bool',
    'byte',
    'char',
    'float32',
    'float64',
    'int8',
    'uint8',
    'int16',
    'uint16',
    'int32',
    'uint32',
    'int64',
    'uint64',
    'string',
    'wstring'
]

# ros_type: ue_type
TYPE_CONVERSION = {
    'bool' : 'bool',
    'int32': 'int',
    'uint32': 'unsigned int',
    'byte': 'uint8',
    'char': 'uint8',
    'float32': 'float',
    'float64': 'double',
    'string': 'FString',
    'wstring': 'FString', 
    'geometry_msgs/Vector3':'FVector',
    'geometry_msgs/Point': 'FVector',
    'geometry_msgs/Quaternion': 'FQuat',
    'geometry_msgs/Transform': 'FTransform'
}

# used in set UPROPERTY to allow BP access
BP_UNSUPPORTED_TYPES = [
    'unsigned int', 
    'double', 
    'int8',
    'int16',
    'uint16',
    'uint64',
    'std::u16string'
]

# UE BP-supported types only?
def convert_to_ue_type(t, pkgs_name_mapping, name_mapping):
    
    #temp
    t = re.sub(r'string<=\d+', 'string', t)
    
    size = 0
    if '[]' in t:
        t = t.replace('[]','')
        t = f'TArray<{convert_to_ue_type(t, pkgs_name_mapping, name_mapping)[0]}>'
    elif ('[' in t) and (']' in t):
        tmp = re.split('\[|\]', t)
        size = tmp[1].replace('<=','')
        t = f'TArray<{convert_to_ue_type(tmp[0], pkgs_name_mapping, name_mapping)[0]}>'
    elif t in TYPE_CONVERSION :
        t = TYPE_CONVERSION[t]
    elif t in ROS_BUILDIN_TYPES:
        pass
    else : #compound msg type
        t = 'FROS' + update_msg_name_full(t, pkgs_name_mapping, name_mapping)

    #elif t == 'geometry_msgs/Pose': -> {FRRDoubleVector, FQuat}
    #elif t == 'geometry_msgs/Twist': -> {FVector TwistLinear, FVector TwistAngular}
    
    return (t, size)

def convert_to_ue_name(n, var_type):
    var_name = snake_to_pascal(n)
    if ('bool' == var_type):
        var_name = f'b{var_name}'

    return var_name

# todo use dict same as type conversion
def get_type_default_value_str(t):
    res = None
    if 'FVector' == t:
        res = 'FVector::ZeroVector'
    elif 'FQuat' == t:
        res = 'FQuat::Identity'
    elif 'FTransform' == t:
        res = 'FTransform::Identity'
    elif t.startswith('F'):
        res = None
    elif 'TArray' in t:
        res = None
    elif 'bool' == t:
        res = 'false'
    elif 'int' in t:
        res = '0'
    elif 'float' in t:
        res = '0.f'
    elif 'double' == t:
        res = '0.f'

    return res

# change pkg name
def update_msg_name_full(in_type, pkgs_name_mapping, name_mapping):
    type_name = in_type
    pkg_name = ''
    if '/' in type_name:
        texts = in_type.split('/')
        pkg_name = texts[0]
        type_name = texts[1]
    return update_msg_name(pkg_name, type_name, pkgs_name_mapping, name_mapping)
    
# change prefix
def update_msg_name(in_pkg, in_type, pkgs_name_mapping, name_mapping):
    # pkg_name update
    if in_pkg in pkgs_name_mapping:
        pkg_name = pkgs_name_mapping[in_pkg]
    else:
        pkg_name = snake_to_pascal(in_pkg)

    # type_name update
    type_name = snake_to_pascal(in_type) 
    for k, v in name_mapping.items():
        if k in type_name:
            type_name = type_name.replace(k, v)

    return pkg_name + type_name

def snake_to_pascal(in_text):
    return ''.join([c[0].upper()+c[1:] for c in in_text.replace('_', ' ').replace('/', ' ').split()])

def camel_to_snake(s):
    arr = []
    for i in range(len(s)):
        temp = s[i].lower()
        if s[i].isupper() and \
            ( # add _ if before or after charactor is lowercase or digit
                (i > 0         and (s[i-1].islower() or s[i-1].isdigit())) or 
                (i != len(s)-1 and (s[i+1].islower() or s[i+1].isdigit()))
            ): # add _ if before or after charactor is lowercase
            temp = '_' + temp
        arr.append(temp)

    return ''.join(arr).lstrip('_')

def remove_underscore(in_text):
    return in_text.replace("_", "")

# generate variable name for UE C++
# original_names: member names defined in .msg, .srv, .action
# return [(type, size), var_name]
def get_ue_var_name(original_names, pkgs_name_mapping, name_mapping):
    if len(original_names) == 2:
        return [
                convert_to_ue_type(original_names[0], pkgs_name_mapping, name_mapping), 
                convert_to_ue_name(original_names[1], original_names[0])
            ]
    else:
        logger.error('ERROR with ' + str(original_names) + ' (get_ue_var_name)')
        return '',''

# generate msg variable access for ROS msg
# original_names: member names defined in .msg, .srv, .action
def get_ros_var_name(original_names={}):
    if len(original_names) == 2:
        vartype = original_names[0]
        varname = original_names[1]
        if re.search('\[\d+\]', original_names[0]) is not None:
            varname += '[i]'
        elif '[]' in original_names[0] or '[<=' in original_names[0]:
            varname += '.data[i]'
        return [str(vartype), str(varname)]
    else:
        logger.error('ERROR with ' + str(original_names) + ' (get_ros_var_name)')
    return '',''


def check_ros_deprecated(file_path):
    content = []
    with open(file_path) as f:
        content = f.readlines()
    for line in content:
        if 'deprecated as of' in line:
            logger.info('{} is deprecated'.format(file_path))
            return True
    return False

# generate code for setter (SetFromROS2)
def setter(r, v_ue, v_ros, size, ros_msg_type):
    ros_msg_type = re.sub(r'\[\d*\]', '', ros_msg_type)

    v_ros_str = 'in_ros_data.' + v_ros
    func_name_str = 'ROSToUE'

    if r.startswith('TArray'):
        r2 = r[len('TArray<'):-len('>')]

        func_name_str = 'Sequence' + func_name_str + 'Array'
        if size > 0:
            size_str = str(size)
            v_ros_str = v_ros_str.replace('[i]', '')
        else:
            size_str = v_ros_str.split('.data[i]', 1)[0] + '.size'
            v_ros_str = v_ros_str.replace('data[i]', 'data')

        body = '(' + v_ros_str + ', ' + v_ue + ', ' + size_str + ')'
        tail = ''
        if r2 in ['FVector', 'FString' ]:
            head = r2[1:] + func_name_str + '<' + ros_msg_type + '>'
        elif r2 in ['FQuat', 'FTransform']:
            head = r2[1:] + func_name_str
        else: # compound
            head = func_name_str + '<' + ros_msg_type + ', ' + r2 + '>'
        head = 'UROS2Utils::' + head

    else:
        head = v_ue
        body = ' = UROS2Utils::' + r[1:] + func_name_str
        tail = '(' + v_ros_str + ')' 
        if r in ['FVector', 'FString' ]:
            body += '<' + ros_msg_type + '>'
        elif r in ['FQuat', 'FTransform']:
            pass
        elif r in ROS_BUILDIN_TYPES or r in TYPE_CONVERSION.values():
            body = ' = '
            tail =  v_ros_str
        else: #compound type
            body = '.SetFromROS2'

    return head + body + tail + ';\n\n\t\t'


def cpp2ros_vector(v_ros, v_ue, comp, is_array=False, is_fixed_size=False):
    iterator = ''
    iterator_ros = ''
    component = ''
    if comp != '':
        component = '.' + comp
    if is_array and is_fixed_size:
        # iterator_ros = '[i]'
        pass
    if is_array:
        iterator = '[i]'
    return 'out_ros_data.' + v_ros + iterator_ros + component.lower() + ' = ' + v_ue + iterator + component.upper() + ';'


def free_and_malloc(v_ros, v_ue, type, Free=False):
    alloc_type = 'decltype(*out_ros_data.' + v_ros + '.data)'
    alloc_type_cast = 'decltype(out_ros_data.' + v_ros + '.data)'
    size = '(' + v_ue + '.Num())'
    # if type == 'FString':
    #     size = '(strLength+1)'
    if type == 'FVector':
        size = '(' + v_ue + '.Num() * 3)'
    elif type == 'FQuat':
        size = '(' + v_ue + '.Num() * 4)'
    free_mem = ''
    if Free:
        free_mem = 'if (out_ros_data.' + v_ros + '.data != nullptr)\n\t\t{\n\t\t\t'\
            + 'free(out_ros_data.' + v_ros + '.data);\n\t\t}\n\t\t'
    return free_mem \
        + 'out_ros_data.' + v_ros + \
        '.data = (' + alloc_type_cast + ')malloc(' + size + \
        '*sizeof(' + alloc_type + '));\n\t\t'

# generate code for getter_AoS - Array-of-Structures (SetROS2)
def getter_AoS(r, v_ue, v_ros, size, ros_msg_type, ros_msg_sequence_type):
    ros_msg_type = re.sub(r'\[\d*\]', '', ros_msg_type)

    v_ros_str = 'out_ros_data.' + v_ros
    func_name_str = 'UEToROS'
    closing_str =  ';\n\n\t\t'

    if r.startswith('TArray'):
        r2 = r[len('TArray<'):-len('>')]
        func_name_str = 'Array' + func_name_str + 'Sequence'
        head = 'UROS2Utils::'
        tail = ''
        if size > 0:
            size_str = str(size)
            v_ros_str = v_ros_str.replace('[i]', '')
        else:
            v_ros_size = v_ros_str.replace('.data[i]', '')                
            size_str = v_ue + '.Num()'
            v_ros_str = v_ros_str.replace('data[i]', 'data')

            # ref https://github.com/ros2/rosidl_typesupport_opensplice/blob/master/rosidl_typesupport_opensplice_c/resource/msg__type_support_c.cpp.em 
            head = 'if (' + v_ros_size + '.data) {' + '\n\t\t' + \
                   ros_msg_sequence_type + '__fini(&' + v_ros_size + ');' + '\n\t\t' + \
                    '}' + '\n\t\t' + \
                   'if (!' + ros_msg_sequence_type + '__init(&' + v_ros_size + ', ' + size_str + ')) {' + \
                        'UE_LOG(LogTemp, Error, TEXT(\"failed to create array for field ' + v_ros_size + '  \"));' + \
                    '}' + '\n\t\t' + head
            # head = ros_msg_sequence_type + '__fini(&' + v_ros_size + ');' + '\n\t\t' + \
            #         ros_msg_sequence_type + '__init(&' + v_ros_size + ', ' + size_str + ');' + \
            #         '\n\t\t' + head

        body = '(' + v_ue + ', ' + v_ros_str + ', ' + size_str + ')'
        if r2 in ['FVector']:
            head += r2[1:] + func_name_str + '<' + ros_msg_type + '>'
        elif r2 in ['FString']:
            t = r2[1:]
            if ros_msg_type == 'rosidl_runtime_c__U16String':
                t = 'U16String'
            head += t + func_name_str
        elif r2 in ['FQuat', 'FTransform']:
            head += r2[1:] + func_name_str
        else: # compound
            head += func_name_str + '<' + ros_msg_type + ', ' + r2 + '>'

    else:
        head = v_ros_str
        body = 'UROS2Utils::' + r[1:] + func_name_str
        tail = '(' + v_ue + ')'
        if r == 'FVector':
            body = ' = ' + body + '<' + ros_msg_type + '>'
        elif r == 'FString':
            head = ''
            t = r[1:]
            if ros_msg_type == 'rosidl_runtime_c__U16String':
                t = 'U16String'
            body = 'UROS2Utils::' + t + func_name_str
            tail = '(' + v_ue + ', ' + v_ros_str + ')'
        elif r in ['FQuat', 'FTransform']:
            body = ' = ' + body
        elif r in ROS_BUILDIN_TYPES or r in TYPE_CONVERSION.values():
            body = ' = '
            tail = v_ue
        else: #compound type
            head = v_ue
            tail = '(' + v_ros_str + ')'
            body = '.SetROS2'

    return head + body + tail + closing_str

def free_and_malloc_SoA(v_ros, v_ue, type):
    alloc_type = 'decltype(*out_ros_data.' + v_ros + '.data)'
    alloc_type_cast = 'decltype(out_ros_data.' + v_ros + '.data)'
    size = '(' + v_ue + '.Num())'
    if type == 'FString':
        size = '(strLength+1)'
    elif type == 'FVector':
        size = '(' + v_ue + '.Num() * 3)'
    elif type == 'FQuat':
        size = '(' + v_ue + '.Num() * 4)'
    return 'if (out_ros_data.' + v_ros + '.data != nullptr)\n\t\t{\n\t\t\t' \
        + 'free(out_ros_data.' + v_ros + '.data);\n\t\t}\n\t\t' \
        + 'out_ros_data.' + v_ros + \
        '.data = (' + alloc_type_cast + ')malloc(' + size + \
        '*sizeof(' + alloc_type + '));\n\t\t'

# generate code for getter_SoA - Structure-of-Arrays (SetROS2)
def getter_SoA(r_array, v_ue_array, v_ros_array, size_array):
    # WARNING: there could be multiple groups of SoA - need to go by matching substrings in v_ros_array
    SoAs_ros = {}
    SoAs_types = {}
    SoAs_r = {}
    for e in range(len(v_ros_array)):
        if v_ros_array[e].split('.data[i].')[0] in SoAs_ros:
            SoAs_ros[v_ros_array[e].split(
                '.data[i].')[0]].append(v_ros_array[e])
            SoAs_types[v_ros_array[e].split(
                '.data[i].')[0]].append(v_ue_array[e])
            SoAs_r[v_ros_array[e].split('.data[i].')[0]].append(r_array[e])
        else:
            SoAs_ros[v_ros_array[e].split('.data[i].')[0]] = [v_ros_array[e]]
            SoAs_types[v_ros_array[e].split('.data[i].')[0]] = [v_ue_array[e]]
            SoAs_r[v_ros_array[e].split('.data[i].')[0]] = [r_array[e]]

    malloc_size = {}
    for t in SoAs_types:
        if t not in malloc_size:
            malloc_size[t] = ''
        malloc_size[t] += SoAs_types[t][0] + '.Num() * '
        malloc_size[t] += '('
        for e in SoAs_types[t]:
            malloc_size[t] += 'sizeof(' + e + ') + '
        malloc_size[t] = malloc_size[t][:-3]
        malloc_size[t] += ')'

    getter_SoA_result = ''
    for t in SoAs_types:
        # free_and_malloc
        getter_SoA_result += 'if (out_ros_data.' + t + '.data != nullptr)\n\t\t{\n\t\t\t' \
            + 'free(out_ros_data.' + t + '.data);\n\t\t}\n\t\t' \
            + 'out_ros_data.' + t + '.data = (decltype(out_ros_data.' + t + '.data))malloc(' + malloc_size[t] + ');\n\t\t' \
            + 'out_ros_data.' + t + '.size = ' + SoAs_types[t][0] + '.Num();\n\t\t' \
            + 'out_ros_data.' + t + '.capacity = ' + \
            SoAs_types[t][0] + '.Num();\n\t\t'
        # fill
        getter_SoA_result += 'for (auto i = 0; i < ' + \
            SoAs_types[t][0] + '.Num(); ++i)\n\t\t{\n\t\t\t'
        for i in range(len(SoAs_types[t])):
            v_ue = SoAs_types[t][i]
            v_ros = SoAs_ros[t][i]
            r = SoAs_r[t][i]
            if 'TArray' in r:
                r = r.split('<', 1)[1].split('>')[0]
            if r == 'FVector':
                getter_SoA_result += cpp2ros_vector(v_ros, v_ue, 'x', True, False) + '\n\t\t\t' \
                    + cpp2ros_vector(v_ros, v_ue, 'y', True, False) + '\n\t\t\t' \
                    + cpp2ros_vector(v_ros, v_ue, 'z',
                                     True, False) + '\n\n\t\t\t'
            elif r == 'FQuat':
                getter_SoA_result += cpp2ros_vector(v_ros, v_ue, 'x', True, False) + '\n\t\t\t' \
                    + cpp2ros_vector(v_ros, v_ue, 'y', True, False) + '\n\t\t\t' \
                    + cpp2ros_vector(v_ros, v_ue, 'z', True, False) + '\n\t\t\t' \
                    + cpp2ros_vector(v_ros, v_ue, 'w',
                                     True, False) + '\n\n\t\t\t'
            elif r == 'FString':
                getter_SoA_result += '{\n\t\t\t\t' \
                    + 'FTCHARToUTF8 strUtf8( *' + v_ue + '[i] );\n\t\t\tint32 strLength = strUtf8.Length();\n\t\t\t\t' \
                    + free_and_malloc(v_ros, v_ue, r, False) \
                    + 'memcpy(out_ros_data.' + v_ros + '.data, TCHAR_TO_UTF8(*' + v_ue + '[i]), (strLength+1)*sizeof(char));\n\t\t\t\t' \
                    + 'out_ros_data.' + v_ros + '.size = strLength;\n\t\t\t\t' \
                    + 'out_ros_data.' + v_ros + '.capacity = strLength + 1;\n\t\t\t' \
                    + '}\n\n\t\t\t'
            elif 'TArray' in r:
                getter_SoA_result += '\t\t\tUE_LOG(LogTemp, Error, TEXT("Not Implemented Yet!"));\n\n'
            else:
                getter_SoA_result += 'out_ros_data.' + \
                    v_ros + ' = ' + v_ue + '[i];\n\n\t\t\t'
        getter_SoA_result += '}\n\t'

    return getter_SoA_result

# extract type name from array type
def msg_cleanup(type_ros):
    r = type_ros.replace('<=','')
    r = re.sub(r'\[\d*\]', '', r)
    return r

# return msg, srv or action
def get_msg_type(type_ros, types_dict):
    r = msg_cleanup(type_ros)
    for t in types_dict:
        if r in types_dict[t]:
            msg_type = t
            break
    if msg_type is None:
        logger.error('get headers: can\'t find include target for ros:{}'.format(r))
    return msg_type

def get_headers(type_ue, type_ros, types_dict):
    res = ''
    u = type_ue
    if u.startswith('TArray'):
        u = type_ue[len('TArray<'):-len('>')]

    r = msg_cleanup(type_ros)
    if r not in ROS_BUILDIN_TYPES and r not in UE_SPECIFIC_TYPES:
        msg_type = get_msg_type(type_ros, types_dict)
        file_name = 'ROS2' + u[4:] + '.h' #len(FROS2)=4
        dir_name = str.capitalize(msg_type) + 's'
        res = '#include \"' + os.path.join(dir_name, file_name) + '\"\n'

    # headers for sequences
    if type_ue.startswith('TArray'):
        res += '#include \"'
        if '/' in type_ros:
            msg_type = get_msg_type(type_ros, types_dict)
            r = ('__' + msg_type + '__').join(r.split('/'))
            seq_type_arr = [camel_to_snake(v) for v in r.split('__')]
            seq_type_arr.insert(2, 'detail')
            res += '/'.join(seq_type_arr) + '__functions.h'
        else:
            if r == 'string':
                res += 'rosidl_runtime_c/string_functions.h'
            elif r == 'wstring':
                res += 'rosidl_runtime_c/u16string_functions.h'
            else:
                res += 'rosidl_runtime_c/primitives_sequence_functions.h'
            
        res += '\"\n'

    return res

# input: k=struct_name, v=[type, name, value]
# return: definition_str, getter_str
def get_constants(k, v):
    type_name = convert_to_ue_type(v[0], {}, {})[0] 
    struct_name = 'FROS' + k + '::'
    constant_name = v[2].strip()
    cdef = ''
    if type_name == 'FString':
        head = 'TEXT(' 
        tail = ')'
        if not constant_name.startswith("\""):
            head += "\""
            tail =  "\"" + tail
        constant_name = head + constant_name + tail
        cdec = '\tstatic const FString ' + v[1] + ';\n'
        cdef = '\tconst FString ' + struct_name + v[1] + ' = ' + constant_name + ';\n'
    else:
        cdec = '\tstatic constexpr ' + type_name + ' ' + v[1] + ' = ' + constant_name + ';\n'

    # UFUNCTION(BlueprintCallable)
    # static int sample()
    # {
    #     return FROSTFStamped::sample;
    # }
    cgetter = ''
    if type_name not in BP_UNSUPPORTED_TYPES:
        cgetter +=  'UFUNCTION(BlueprintCallable)\n\t'
    cgetter += \
        'static ' + type_name + ' CONST_' + v[1] + '()\n\t' + \
        '{\n\t\t' + \
            'return FROS' + k + '::' + v[1] + ';\n\t' + \
        '}\n\t'
    return cdec, cgetter, cdef

def get_constructors(r, v_ue, size):
    
    # Initialize fixed size array
    if size <= 0:
        return ''

    if not r.startswith('TArray'):
        return ''

    return v_ue + '.SetNumZeroed(' + str(size) + ');\n\n\t\t'
        
# scan msg, srv and action files to find all types present in the given target_paths
def get_types(target_paths):
    logger.debug('\n\n*************************** \n get types \n***************************')
    types = set(ROS_BUILDIN_TYPES)
    for target_path in target_paths:
        for subdir, dirs, files in os.walk(target_path):
            files = [fi for fi in files if fi.endswith(
                ('.msg', '.srv', '.action'))]
            # compose filename with path
            filepaths = [os.path.join(subdir, filename) for filename in files]
            for fp in filepaths:
                logger.debug('get types: get type from {}'.format(fp))
                content = []
                # load all data of the file into content, line by line
                with open(fp) as f:
                    content = f.readlines()

                # remove leading and trailing spaces, including new lines '\n'
                content = [x.strip() for x in content]

                # ignore empty lines ''
                content = [c for c in content if c != '']

                # ignore comment lines '#'
                content = [c for c in content if not c.startswith('#')]

                # ignore separator lines '---'
                content = [c for c in content if c != '---']

                # Get type
                content = [c.split()[0] for c in content]

                # remove array sizes
                content = [re.sub(r'<=', '', c) for c in content]

                # remove array markers '[]'
                content = [re.sub(r'\[\d*\]', '', c) for c in content]


                # get pkg name
                el = fp.split('/')
                pkg_name = el[len(el)-3] + '/'

                # include complex types (self)
                for c in content:
                    if c not in types:
                        # make full type name
                        type_name = c
                        if type_name not in ROS_BUILDIN_TYPES and '/' not in type_name:
                            type_name = pkg_name + type_name
                        logger.debug('get types: add types: {}'.format(type_name))
                        types.add(type_name)

                el = fp.split('/')
                struct_type = pkg_name + remove_underscore(os.path.splitext(os.path.basename(fp))[0])
                if struct_type not in types:
                    logger.debug('get types: add types: {}'.format(struct_type))
                    types.add(struct_type)
    
    # logger.debug('get types: {}'.format(types))
    return types


# create a dictionary matching types with the corresponding expanded contents expressed with basic types
def get_types_dict(target_paths):
    types_dict = {'msg': {}, 'srv': {}, 'action': {}}
    types = get_types(target_paths)
    logger.debug('\n\n*************************** \n get_types_dict \n***************************')

    def print_duplication_error(in_text):
        logger.error('Type name ' + in_text + ' is duplicated. Please check definition overlapping.')
        sys.exit(1)

    # for every folder to scan
    for target_path in target_paths:
        logger.info('get_types_dict: target path: {}'.format(target_path))
        pkg_name = os.path.basename(target_path) + '/'

        # iterate all subfolders
        for subdir, dirs, files in os.walk(target_path):
            # iterate over all msg, srv and action files
            files = [fi for fi in files if fi.endswith(('.msg', '.srv', '.action'))]
            for fi in files:

                logger.debug('get_types_dict: target file {}'.format(fi))
                content = []

                # if the file corresponds to the type t being processed
                fi_name = os.path.splitext(fi)[0]
                t = pkg_name + remove_underscore(fi_name)
                tRequest = f'{t}Req'
                tResponse = f'{t}Res'
                tSendGoal = f'{t}SGReq'
                tGetResult = f'{t}GRRes'
                tFeedback = f'{t}FB'
            
            # if struct_type == t:
                # logger.debug('get_types_dict: type and file matches. filename: {}'.format(t))
                
                # load all data of the file into content, line by line
                with open(os.path.join(subdir, fi)) as f:
                    content = f.readlines()

                # remove leading and trailing spaces, including new lines '\n'
                content = [x.strip() for x in content]

                content = [
                    c for c in content if not c.startswith('#') and c != '']
                content = [c.split('#')[0] for c in content]

                constants = [c for c in content if '=' in c and ('<=' not in c)]

                # remove constants - these will eventually need to be used
                content = [c for c in content if '=' not in c or ('<=' in c)]

                # sprit type and name
                content = [c.split()[0:2] if c != '---' else c for c in content ]

                # make full type name
                for c in content:
                    if c == '---':
                        continue
                    temp_name = re.sub(r'<=', '', c[0])
                    temp_name = re.sub(r'\[\d*\]', '', temp_name)
                    if temp_name not in ROS_BUILDIN_TYPES and '/' not in temp_name:
                        c[0] = pkg_name + c[0]
                
                # parse constants to [type name value]
                for c in constants:
                    c = c.split() # split type, name and value
                    const_v= c[1:] # [typename=value] or [typename, =, value]
                    const_v = ''.join(const_v).split('=') # [typename, value]
                    c = [c[0], const_v[0], const_v[1]] #[typename, name, value]
                    content.append(c)

                if fi.endswith('.msg'):
                    # remove comments, empty and separator lines; keep only variable type and name
                    # content = [ c for c in content if '=' not in c[1] ] # ignore constants
                    if t in types_dict['msg']:
                        print_duplication_error(t)
                    types_dict['msg'][t] = content
                    logger.debug('get_types_dict: msg: parsed result: {}: {}'.format(t, content))
                elif fi.endswith('.srv'):
                    counter = 0
                    logger.debug('get_types_dict: srv: parsed result')

                    if tRequest in types_dict['srv']:
                        print_duplication_error(tRequest)
                    if tResponse in types_dict['srv']:
                        print_duplication_error(tResponse)
                    
                    for c in content:
                        if not c == '---':
                            if counter == 0:
                                if (tRequest in types_dict['srv']): # and (c not in types_dict['srv'][tRequest]):
                                    types_dict['srv'][tRequest].append(c)
                                else:
                                    types_dict['srv'][tRequest] = [c]
                                logger.debug('get_types_dict: srv: parsed request: {}'.format(c))
                            elif counter == 1:
                                if (tResponse in types_dict['srv']): # and (c not in types_dict['srv'][tResponse]):
                                    types_dict['srv'][tResponse].append(c)
                                else:
                                    types_dict['srv'][tResponse] = [c]
                                logger.debug('get_types_dict: srv: parsed response: {}'.format(c))
                        else:
                            counter += 1
                elif fi.endswith('.action'):
                    # remove comments and empty lines; keep only variable type and name
                    counter = 0
                    logger.debug('get_types_dict: action: parsed result')

                    if tSendGoal in types_dict['action']:
                        print_duplication_error(tSendGoal)
                    if tGetResult in types_dict['action']:
                        print_duplication_error(tGetResult)
                    if tFeedback in types_dict['action']:
                        print_duplication_error(tFeedback)

                    for c in content:
                        if not c == '---':
                            if '=' not in c[1]:
                                if counter == 0:
                                    if (tSendGoal in types_dict['action']): # and (c not in types_dict['action'][tSendGoal]):
                                        types_dict['action'][tSendGoal].append(c)
                                    else:
                                        types_dict['action'][tSendGoal] = [c]
                                    logger.debug('get_types_dict: action send goal: parsed goal: {}'.format(c))
                                elif counter == 1:
                                    if (tGetResult in types_dict['action']): # and (c not in types_dict['action'][tGetResult]):
                                        types_dict['action'][tGetResult].append(c)
                                    else:
                                        types_dict['action'][tGetResult] = [c]
                                    logger.debug('get_types_dict: action get result: parsed result: {}'.format(c))
                                elif counter == 2:
                                    if (tFeedback in types_dict['action']): # and (c not in types_dict['action'][tFeedback]):
                                        types_dict['action'][tFeedback].append(c)
                                    else:
                                        types_dict['action'][tFeedback] = [c]
                                    logger.debug('get_types_dict: action feedback: parsed feedback: {}'.format(c))
                        else:
                            counter += 1
                logger.debug('\n')

    # remove complex types that have a corresponding UE type
    # for ue_type in UE_SPECIFIC_TYPES:
    #     types_dict.pop(ue_type, None)

    # traverse and add complex type breakdown
    # for key, value in types_dict.items():
    #     for index, c in enumerate(value):
    #         print(index, c)
    #         v = c[0].replace('[]', '')
    #         if v in types_dict:
    #             value[index] = [c[0], c[1], types_dict[v]]
    for type_name in types_dict:
        for key, value in types_dict[type_name].items():
            logger.debug('get_types_dict: ' + str(key) + ' -> ' + str(value))

    return types_dict


# generate UE & ROS C++ code snippets to be inserted in their respective placeholders in the templates
# element 0: type
# element 1: set from ros2
# element 2: set ros2
def get_types_cpp(target_paths, pkgs_name_mapping, name_mapping):
    types_dict = get_types_dict(target_paths)
    types_cpp = {}

    logger.debug('\n\n*************************** \n get_types_cpp \n***************************')
    for type_name in types_dict:
        for key, value in types_dict[type_name].items():
            cpp_type = ''
            set_ros2 = ''
            set_from_ros2 = ''
            constructor = ''
            headers = ''
            constants = {'dec': '', 'getter': '', 'def': ''}
            logger.debug('get_types_cpp: parse input {} {}'.format(key, value))
            new_key = update_msg_name_full(key, pkgs_name_mapping, name_mapping)
            for v in value:
                logger.debug("input: {}".format(v))

                # parse constants
                if len(v) >= 3:
                    logger.debug("parse constant: {}".format(v))
                    cdec, cgetter, cdef = get_constants(new_key, v)
                    constants['dec'] += cdec
                    constants['getter'] += cgetter
                    constants['def'] += cdef
                    continue

                res_ue = get_ue_var_name(v, pkgs_name_mapping, name_mapping)
                logger.debug("res_ue: {}".format(res_ue))
                res_ros = get_ros_var_name(v)
                logger.debug("res_ros: {}".format(res_ros))

                t_ue_array = []
                v_ue_array = []
                v_ros_array = []
                size_array = []

                it_ros = iter(res_ros)


                for i in range(0, len(res_ue), 2):
                    t_ue = res_ue[i]
                    v_ue = res_ue[i + 1]
                    type_ros = res_ros[i]

                    # used as input to template
                    ros_msg_type = msg_cleanup(type_ros)
                    ros_msg_sequence_type = ''
                    if '/' in type_ros:
                        msg_type = get_msg_type(type_ros, types_dict)
                        ros_msg_type = ('__' + msg_type + '__').join(ros_msg_type.split('/'))
                        ros_msg_sequence_type = ros_msg_type + '__Sequence'
                    else:
                        if ros_msg_type == 'string':
                            ros_msg_type = 'rosidl_runtime_c__String'
                            ros_msg_sequence_type = ros_msg_type + '__Sequence'
                        elif ros_msg_type == 'wstring':
                            ros_msg_type = 'rosidl_runtime_c__U16String'
                            ros_msg_sequence_type = ros_msg_type + '__Sequence'
                        else:
                            ros_msg_sequence_type = 'rosidl_runtime_c__' + ros_msg_type + '__Sequence'
                            if ros_msg_type in ['int64', 'uint64']: #why this is required?
                                ros_msg_type += '_t'
                            elif ros_msg_type in TYPE_CONVERSION.keys():
                                ros_msg_type = TYPE_CONVERSION[ros_msg_type]

                    type_ue = t_ue[0]
                    size = int(t_ue[1])
                    
                    # ros_type
                    next(it_ros)
                    # ros_var
                    v_ros = next(it_ros)

                    # BP does not support these types
                    dft_val = get_type_default_value_str(type_ue)
                    var_initialization = f' = {dft_val}' if (dft_val != None) else ''
                    var_declaration = f'{type_ue} {v_ue}{var_initialization};\n\n\t'
                    
                    # check bp_supported or not
                    bp_supported = True
                    if type_ue in BP_UNSUPPORTED_TYPES:
                        bp_supported = False                    
                    elif 'TArray' in type_ue:
                        for msg_type in BP_UNSUPPORTED_TYPES:
                            if msg_type in type_ue:
                                bp_supported = False
                                break
                    if bp_supported:
                        cpp_type += 'UPROPERTY(EditAnywhere, BlueprintReadWrite)\n\t' + var_declaration
                    else:
                        cpp_type += 'UPROPERTY(EditAnywhere)\n\t' + var_declaration

                    # Headers
                    headers += get_headers(type_ue, type_ros, types_dict)

                    # Constructors
                    constructor += get_constructors(type_ue, v_ue, size)
                    
                    # SetFromROS
                    set_from_ros2 += setter(type_ue, v_ue, v_ros, size, ros_msg_type)

                    # SetROS2
                    if '.data[i].' not in v_ros:
                        set_ros2 += getter_AoS(type_ue, v_ue, v_ros, size, ros_msg_type, ros_msg_sequence_type)
                    else:
                        t_ue_array.append(type_ue)
                        v_ue_array.append(v_ue)
                        v_ros_array.append(v_ros)
                        size_array.append(size)

                # if any('.data[i].' in vr for vr in v_ros_array) and any('fields_' in vt for vt in v_ue_array) and not any('_fields_' in vt for vt in v_ue_array):
                #     print('getter with:\n' + str(t_ue_array) + '\n' + str(v_ue_array) + '\n' + str(v_ros_array) + '\n' + str(size_array))
                
                # this may not happen any more?
                if len(t_ue_array) > 0:
                    set_ros2 += getter_SoA(t_ue_array, v_ue_array,
                                        v_ros_array, size_array)

            logger.debug('get_types_cpp: parsed result {} {}'.format(new_key, [cpp_type, set_from_ros2, set_ros2, constructor, headers, constants]))
            types_cpp[new_key] = [cpp_type, set_from_ros2, set_ros2, constructor, headers, constants]

    # for key, value in types_cpp.items():
    #    print(str(key) + ' -> ' + str(value[2]))
    #    print(str(key) + ' -> ' + str(value[0]))

    return types_cpp

############################################
# main process
############################################

def codegen(module, dependency, target, name_mapping, ros_ws = os.path.join(os.getcwd(), '../ros2_ws'),):
    file_loader = FileSystemLoader('templates')
    env = Environment(loader=file_loader)
    current_dir = os.getcwd()

    # print(module, dependency, target, name_mapping)
    # sys.exit(1)

    # cleanup
    os.system('rm -r Msgs Srvs Actions')
    os.system('mkdir Msgs Srvs Actions')

    module_api = module.upper() + '_API'
    
    ros_paths = [os.path.join(ros_ws, pkg) for pkg in dependency.keys()]
    groups = []

    # defautl is same as dependency
    if target is None:
        ue_paths = ros_paths
    else:
        ue_paths = [os.path.join(ros_ws, pkg) for pkg in target.keys()]

    for path in dependency:
        path = path.rstrip('/') #removing trailing slash
        if path not in ros_paths:
            ros_paths.append(path)

    for path in ue_paths:
        path = path.rstrip('/') #removing trailing slash
        if path not in ros_paths:
            ros_paths.append(path)

    for path in ue_paths:
        groups.append(os.path.basename(path))

    logger.debug('ros_paths: {}'.format(ros_paths))
    logger.debug('ue_paths: {}'.format(ue_paths))
    logger.debug('groups: {}'.format(groups))

    pkgs_name_mapping = {**dependency, **target}
    types_cpp = get_types_cpp(ros_paths, pkgs_name_mapping, name_mapping)
    def is_valid_group_name(in_group_name):
        return ((in_group_name in types_cpp) and len(types_cpp[in_group_name]) >= 3)

    def print_group_name_info(in_group_name):
        logger.warning(f"Error in parsing msg or msg is empty. types_cpp[{in_group_name}] \
            size:{len(types_cpp[in_group_name]) if (in_group_name in types_cpp) else 0}")

    # generate code
    SUB_DIRS =[*['action', 'srv', 'msg']]
    for p in range(len(ue_paths)):
        subdir_path = f'{ue_paths[p]}'
        pkg_name = os.path.basename(subdir_path)
        if not os.path.exists(subdir_path):
            continue
        logger.debug('[ROS2 PKG SHARE PATH]: {}'.format(subdir_path))

        for subdir in SUB_DIRS:
            file_type = os.path.dirname(subdir) if '\/' in subdir else subdir
            logger.info('INPUT ROS2 DIR:' + subdir_path + ' -> Output DIR:' + current_dir)
            for file_path in Path(subdir_path).rglob(f'*.{file_type}'):
                
                name = Path(file_path).stem
                # Not accept ROS file name having '_'
                if('_' in name):
                    continue
                ue_name = update_msg_name(pkg_name, name, pkgs_name_mapping, name_mapping)
                print(ue_name)
                name_cap = snake_to_pascal(name)

                logger.debug(' INPUT ROS2 FILE:' + os.path.basename(file_path))
                if check_ros_deprecated(file_path):
                    continue

                info = {}
                file_path_parts = file_path.parts
                info['Filename'] = os.path.join(*list(file_path_parts[len(file_path_parts)-3:len(file_path_parts)])) #get last 3 parts of msg such as nav_msgs/msg/Odometry.msg
                info['Group'] = groups[p]
                
                # PascalCase to snake_case; correctly handles acronyms: TLA -> tla instead of t_l_a
                name_lower = re.sub(
                    '([a-z0-9])([A-Z])', r'\1_\2', re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)).lower()
                info['Name'] = name_lower
                info['NameCap'] = name_cap
                info['UEName'] = ue_name
                info['ModuleAPI'] = module_api

                # p_group_name = f"{groups[p]}/{name}"
                # group_name = p_group_name
                p_group_name = ue_name
                if file_type == 'msg':
                    group_name = p_group_name
                    if(is_valid_group_name(group_name)):
                        info['Types'] = types_cpp[group_name][0]
                        info['SetFromROS2'] = types_cpp[group_name][1]
                        info['SetROS2'] = types_cpp[group_name][2]
                        info['Constructor'] = types_cpp[group_name][3]
                        info['Headers'] = types_cpp[group_name][4]
                        info['ConstantsDec'] = types_cpp[group_name][5]['dec']
                        info['ConstantsGetter'] = types_cpp[group_name][5]['getter']
                        info['ConstantsDef'] = types_cpp[group_name][5]['def']
                    else:
                        print_group_name_info(group_name)

                elif file_type == 'srv':
                    group_name = f"{p_group_name}Req"
                    if(is_valid_group_name(group_name)):
                        info['ReqTypes'] = types_cpp[group_name][0]
                        info['ReqSetFromROS2'] = types_cpp[group_name][1]
                        info['ReqSetROS2'] = types_cpp[group_name][2]
                        info['ReqConstructor'] = types_cpp[group_name][3]
                        info['ReqHeaders'] = types_cpp[group_name][4]
                        info['ReqConstantsDec'] = types_cpp[group_name][5]['dec']
                        info['ReqConstantsGetter'] = types_cpp[group_name][5]['getter']
                        info['ReqConstantsDef'] = types_cpp[group_name][5]['def']
                    else:
                        print_group_name_info(group_name)

                    group_name = f"{p_group_name}Res"
                    if(is_valid_group_name(group_name)):
                        info['ResTypes'] = types_cpp[group_name][0]
                        info['ResSetFromROS2'] = types_cpp[group_name][1]
                        info['ResSetROS2'] = types_cpp[group_name][2]
                        info['ResConstructor'] = types_cpp[group_name][3]
                        info['ResHeaders'] = types_cpp[group_name][4]
                        info['ResConstantsDec'] = types_cpp[group_name][5]['dec']
                        info['ResConstantsGetter'] = types_cpp[group_name][5]['getter']
                        info['ResConstantsDef'] = types_cpp[group_name][5]['def']
                    else:
                        print_group_name_info(group_name)

                elif file_type == 'action':
                    group_name = f"{p_group_name}SGReq"
                    if(is_valid_group_name(group_name)):
                        info['GoalTypes'] = types_cpp[group_name][0]
                        info['GoalSetFromROS2'] = types_cpp[group_name][1].replace(
                            'in_ros_data.', 'in_ros_data.goal.')
                        info['GoalSetROS2'] = types_cpp[group_name][2].replace(
                            'out_ros_data.', 'out_ros_data.goal.')
                        info['GoalConstructor'] = types_cpp[group_name][3]
                        info['GoalHeaders'] = types_cpp[group_name][4]
                        info['GoalConstantsDec'] = types_cpp[group_name][5]['dec']
                        info['GoalConstantsGetter'] = types_cpp[group_name][5]['getter']
                        info['GoalConstantsDef'] = types_cpp[group_name][5]['def']
                    else:
                        print_group_name_info(group_name)

                    group_name = f"{p_group_name}GRRes"
                    if(is_valid_group_name(group_name)):
                        info['ResultTypes'] = types_cpp[group_name][0]
                        info['ResultSetFromROS2'] = types_cpp[group_name][1].replace(
                            'in_ros_data.', 'in_ros_data.result.')
                        info['ResultSetROS2'] = types_cpp[group_name][2].replace(
                            'out_ros_data.', 'out_ros_data.result.')
                        info['ResultConstructor'] = types_cpp[group_name][3]
                        info['ResultHeaders'] = types_cpp[group_name][4]
                        info['ResultConstantsDec'] = types_cpp[group_name][5]['dec']
                        info['ResultConstantsGetter'] = types_cpp[group_name][5]['getter']
                        info['ResultConstantsDef'] = types_cpp[group_name][5]['def']
                    else:
                        print_group_name_info(group_name)

                    group_name = f"{p_group_name}FB"
                    if(is_valid_group_name(group_name)):
                        info['FeedbackTypes'] = types_cpp[group_name][0]
                        info['FeedbackSetFromROS2'] = types_cpp[group_name][1].replace(
                            'in_ros_data.', 'in_ros_data.feedback.')
                        info['FeedbackSetROS2'] = types_cpp[group_name][2].replace(
                            'out_ros_data.', 'out_ros_data.feedback.')
                        info['FeedbackConstructor'] = types_cpp[group_name][3]
                        info['FeedbackHeaders'] = types_cpp[group_name][4]
                        info['FeedbackConstantsDec'] = types_cpp[group_name][5]['dec']
                        info['FeedbackConstantsGetter'] = types_cpp[group_name][5]['getter']
                        info['FeedbackConstantsDef'] = types_cpp[group_name][5]['def']
                    else:
                        print_group_name_info(group_name)

                os.chdir(current_dir)

                output_h = ''
                output_cpp = ''
                if file_type == 'msg':
                    output_h = env.get_template('Msg.h').render(data=info)
                    output_cpp = env.get_template(
                        'Msg.cpp').render(data=info)
                elif file_type == 'srv':
                    output_h = env.get_template('Srv.h').render(data=info)
                    output_cpp = env.get_template(
                        'Srv.cpp').render(data=info)
                elif file_type == 'action':
                    output_h = env.get_template(
                        'Action.h').render(data=info)
                    output_cpp = env.get_template(
                        'Action.cpp').render(data=info)
                else:
                    logger.error('type not found: {}'.format(subdir))

                # this should only happen if the file does not exist
                output_filename = f'{current_dir}/{file_type.capitalize()}s/ROS2{ue_name}'
                logger.debug(' OUTPUT UE FILE:' + os.path.basename(output_filename))
                logger.info(' Generate: ' +  os.path.basename(file_path) + ' -> ' + os.path.basename(output_filename) )
                file_h = open(f'{output_filename}.h', 'w')
                file_cpp = open(f'{output_filename}.cpp', 'w')

                file_h.write(output_h)
                file_cpp.write(output_cpp)

                file_h.close()
                file_cpp.close()

    # this seems not work property. Temporary relay on pre-commit hook on each repo.
    os.system('./format.sh') #apply clang-format

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Generate C++ files for rclUE from ROS2 msgs.')
    parser.add_argument('--module', default='RCLUE', help='UE module name used in class/struct definition.')
    parser.add_argument('--dependency', nargs='*', default=DEFAULT_DEPENDENCY_PKGS, help='path to directory which include \
        dependency of target. You can specify UE_tools/ros2_ws to include all build \
        pkgs as dependency, but it take longer to process.')
    parser.add_argument('--target', nargs='*', help='path to directory which has target msg files')
    parser.add_argument('--name_mapping', nargs='*', default=DEFAULT_NAME_MAPPING, help='name mapping to replace specific words.')
    parser.add_argument('--ue_target_ros_wrapper_path', default='', help='path to directory which has header files')
    args = parser.parse_args()

    target = args.target
    if target is None:
        target = args.dependency

    codegen(
        module = args.module,
        dependency = args.dependency,
        target = target,
        name_mapping = args.name_mapping
    )